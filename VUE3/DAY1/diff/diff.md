# 什么是虚拟DOM(vnode)
简介：利用js对象来模拟DOM结构,将每一个标签转为一个对象
<template>
    <div id='app' class='container'>
        <h1>tycho</h1>
    </div>
</template>

转为

{
    tag:'div',
    props:{id:'app',class:'container'},
    children:[
        {tag:'h1',children:'tycho'}
    ]
}
# 什么是diff算法
在vue中叫做patch，通过新旧虚拟DOM对比（即patch过程），找出最小变化的地方转为进行DOM操作
## 什么时候执行patch
- 页面首次渲染时
- 组件中数据发送变化时
## patch干了什么
# VUE2_diff —— 双端比较
原理：将新旧列表的头尾相互比较，同时往指针向中间靠拢，直到某一个列表的节点全部遍历过，停止对比
对比方法：
- 旧列表头节点 对比 新列表头结点
- 旧列表尾节点 对比 新列表尾结点
- 旧列表头节点 对比 新列表尾结点
- 旧列表尾节点 对比 新列表头结点

通过以上对比，找到key中相同可复用的节点，patch给元素打补丁，然后移动指针

非理想状态：通过以上4步仍没有找到可用节点，
则拿新列表的第一个节点去就列表中找
- 找到了：
    - 将旧列表中找到的元素移到开头，并把节点改为undefined，newStarIndex++
- 没找到：
    - 直接创建一个新的节点放到最前面，然后newStartIndex++
## 添加节点
## 移除节点
# VUE3_diff —— 最长递增子序列
原理：
- 相同的前置和后置元素的预处理
- 最长递增子序列

1、j>oldEnd && j<= newEnd
2、j>newEnd && j<= oldEnd
3、非理想状态

## 非理想状态
构造source：长度为新一组节点经过预处理，剩余未处理节点的数量，元素初始值为-1；
suorce作用：存储新组子节点中的节点在旧组子节点中的位置索引，后面通过其计算出一个最长递增子序列，辅助DOM移动操作；

### 判断节点是否需要移动